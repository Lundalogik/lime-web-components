---
name: Hello, Task!
route: /hello-task
menu: Tutorials
---

# Hello, Task!

This guide will show how to use the task service to create a new task that will run asynchronously and display a simple
toast when it has completed.

## Generate a task

We will start by creating a new plugin named "Sleepy" that will sleep for a period of time and return a message when it
is done. We will need to generate the following:

* A translation module
* A command to put into the action menu in the table view
* An endpoint that creates the task
* The task itself

```bash
lime-project new plugin
cd sleepy
lime-project generate translation-module
lime-project generate command sleep
lime-project generate tasks
```

## The command

The command will take a number as argument that represents the number of seconds that the task will be asleep for. The
timeout will be configurable from the config when it is added to the action menu.

Add the `timeout` property to the `SleepCommand` class.

```typescript
// frontend/src/commands/sleep/sleep.command.ts

@Command({
    id: 'sleepy.sleep'
})
export class SleepCommand {
    public timeout: number;
}
```

In the command handler, we are going to use the `TaskService` to create the task.

```typescript
// frontend/src/commands/sleep/sleep.handler.ts

export class SleepHandler implements CommandHandler {
    constructor(private tasks: TaskService) {}

    public async handle(command: SleepCommand) {
        const url = 'sleepy/task/sleep/';

        const id = await this.tasks.create(url, command);
        console.log(`Created task with id ${id}`);
    }
}
```

We also need to register our handler with our command in the `Loader` component

```typescript
// frontend/src/components/lwc-sleepy-loader/lwc-sleepy-loader.tsx

export class Loader implements LimePluginLoader {
    public componentWillLoad() {
        this.platform.commandBus.register(SleepCommand, new SleepHandler(this.platform.state.tasks));
    }
}
```

 All frontend coding is done now so we can go ahead and build the project.

 ```bash
 cd frontend
 npm run build
 ```

## The endpoint

The endpoint that was generated is responsible for creating the task. The file `sleepy/endpoints/task_endpoint.py`
contains some autogenerated code that we can replace with our own.

```python
sleep_args = {
    "timeout": fields.Number(required=True)
}

class SleepyTaskHandler(webserver.LimeResource):
    @use_args(sleep_args)
    def post(self, args):
        identifier = self.application.identifier
        return lime_task.send_task(
                'sleepy.tasks.tasks.sleep',
                identifier,
                args['timeout']).to_dict()

api.add_resource(SleepyTaskHandler, '/task/sleep/')
```

## The task

The task itself is really simple, it will just sleep for the given amount of time and then return a message. We can
remove all of the autogenerated code in `sleepy/tasks/tasks.py` and add our own.

```python
from lime_task import task
import time

@task
def sleep(app, timeout):
    time.sleep(timeout)

    return "Slept for " + str(timeout) + " seconds"
```

## Installation and configuration

All coding should be done now and we can go ahead and install our plugin. Please note that the plugin needs to be
installed both on the appserver and on the taskhandler. Once installed, both services have to be restarted.

To add our command to the action menu in the table view, we need to configure the table view for the one of the
limetypes in lime-admin. The following snippet will add our action and configure our task to sleep for 15 seconds.

```json
{
  "actions": [{
    "id": "sleepy.sleep",
    "params": {
      "timeout": 15
    }
  }]
}
```

## Testing our plugin

We can now go ahead and test our plugin. Navigate to the table that has the action added to the menu and click it. A
notification should be displayed indicating that the task is about to be created. Unless it is canceled, a new
notification should be displayed telling us that it was created successfully. Depending on how much work is being done
on the taskhandler, the task might have been queued up so there is no way of knowing how long it will take until it
returns a result. After a while though it should return and a new message should be displayed with the result of the
operation.
