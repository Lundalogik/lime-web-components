(window.webpackJsonp=window.webpackJsonp||[]).push([[18],{"./doc/concepts/state.mdx":function(e,n,t){"use strict";t.r(n);var a=t("./node_modules/react/index.js"),o=t.n(a),r=t("./node_modules/@mdx-js/tag/dist/index.js");function s(e,n){if(null==e)return{};var t,a,o=function(e,n){if(null==e)return{};var t,a,o={},r=Object.keys(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)t=r[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}n.default=function(e){var n=e.components;s(e,["components"]);return o.a.createElement(r.MDXTag,{name:"wrapper",components:n},o.a.createElement(r.MDXTag,{name:"h1",components:n,props:{id:"state"}},"State"),o.a.createElement(r.MDXTag,{name:"p",components:n},"The state in the webclient stores all information related to data. It can be limetypes, loaded limeobjects, the current\nuser etc."),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"connecting-to-the-state"}},"Connecting to the state"),o.a.createElement(r.MDXTag,{name:"p",components:n},"To use the state, a property in a web component must be connected to it. This is done by decorating the property with\na state decorator. The example below shows how to connect to the state to get the current logged in user."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-tsx",metaString:""}},"export class MyComponent implements LimeWebComponent {\n\n    @CurrentUser()\n    @State()\n    private user: object;\n\n    public render() {\n        return <p>Hello {this.user.fullname}!</p>;\n    }\n}\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"filtering-the-result-with-arguments"}},"Filtering the result with arguments"),o.a.createElement(r.MDXTag,{name:"p",components:n},"It's also possible to send arguments into the decorator in order to make it more specific. The following example will\nload all loaded limeobjects into the connected property."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-tsx",metaString:""}},"export class MyComponent implements LimeWebComponent {\n\n    @Limeobjects()\n    @State()\n    private limeobjects: object;\n}\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"If we only want objects of a specific limetype, we can specify that limetype when decorating the property. The\nfollowing will give us all currenyly loaded persons"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-tsx",metaString:""}},"export class MyComponent implements LimeWebComponent {\n\n    @Limeobjects({\n        limetype: 'person'\n    })\n    @State()\n    private persons = [];\n}\n")),o.a.createElement(r.MDXTag,{name:"h2",components:n,props:{id:"using-a-mapping-function"}},"Using a mapping function"),o.a.createElement(r.MDXTag,{name:"p",components:n},"While this is useful, it can be made even more useful if combined with a mapping function. Let's say we have a web\ncomponent that is displayed on the company card, and we want a list of all persons connected to that company. First, we\ncan define a filtering function that filters out our persons like this:"),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-js",metaString:""}},"function currentPersons(persons = []) {\n    return persons.filter(person => person.company === this.context.id);\n}\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"This function takes a list of persons, and returns a new list which only contains persons of the company in the current\ncontext."),o.a.createElement(r.MDXTag,{name:"p",components:n},"We can apply this filtering function by specifying it when decorating our property."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-tsx",metaString:""}},"export class MyComponent implements LimeWebComponent {\n\n    @Limeobjects({\n        limetype: 'person',\n        map: [currentPersons]\n    })\n    @State()\n    private persons = [];\n}\n")),o.a.createElement(r.MDXTag,{name:"p",components:n},"This will map the original result (a list of all persons) to a new result (a filtered list of persons) that is stored\nin the connected property."),o.a.createElement(r.MDXTag,{name:"p",components:n},"There are also two specific decorators that can be used to get the limetype and limeobject of the current context.\nUnder the hood, these are just implemented with the map functionality used above."),o.a.createElement(r.MDXTag,{name:"pre",components:n},o.a.createElement(r.MDXTag,{name:"code",components:n,parentName:"pre",props:{className:"language-tsx",metaString:""}},"import { CurrentLimeobject, CurrentLimetype } from 'lime-web-component-interfaces/state';\n\nexport class MyComponent implements LimeWebComponent {\n\n    @CurrentLimeobject()\n    @State()\n    private limeobject: object;\n\n    @CurrentLimetype()\n    @State()\n    private limetype: object;\n}\n")))}}}]);